[[class-loaders]]
= Class Loaders

Understanding Payara Server class loaders can help you determine where to place supporting JAR and resource files for your modules and applications.

In a JVM implementation, the class loaders dynamically load a specific Java class file needed for resolving a dependency. For example, when an instance of
`java.util.Enumeration` needs to be created, one of the class loaders loads the relevant class into the environment.

For information about class loader debugging, see xref:docs:application-development-guide:debugging-apps.adoc#class-loader-debugging[Class Loader Debugging].

[[the-class-loader-hierarchy]]
== The Class Loader Hierarchy

Class loaders in the Payara Server runtime follow a delegation hierarchy that is illustrated in the following figure and fully described in the following table:

[width="100%",cols="20%,80%a",options="header",]
|===
|Class Loader |Description

|Bootstrap 
|The Bootstrap class loader loads the basic runtime classes provided by the JVM.

|Public API 
|The Public API class loader makes available all classes specifically exported by the Payara Server runtime for use by deployed applications.

This includes, but is not limited to, Jakarta EE API, Eclipse MicroProfile and the Payara Platform Public API.

Parents the Common class loader.

|Common 
|The Common class loader loads JAR files in the`${as-install}/lib` directory, followed by JAR files in the `${domain-dir}/lib` directory. Using `${domain-dir}/lib` is recommended whenever possible, and required for custom login modules and security realms.

Parents the Connector class loader.

|Connector 
|The Connector class loader is a single class loader instance that loads individually deployed connector modules, which are shared across all applications.

Parents both the *Applib* class loader and the *LifeCycleModule* class loader.

|LifeCycleModule 
|The LifeCycleModule class loader is created once per lifecycle module. Each lifecycle module's classpath is used to construct its own class loader.

For more information on lifecycle modules, see xref:docs:application-development-guide:lifecycle-listeners.adoc#developing-lifecycle-listeners[Developing Lifecycle Listeners].

|Applib
|The `Applib` class loader loads the library classes, specified during deployment, for a specific enabled module or Jakarta EE application;

One instance of this class loader is present in each class loader universe;

Parents the Archive class loader.

NOTE: When multiple deployed applications use the same library, they share the same instance of the library. One library cannot reference classes from another library.

|Archive 
|The Archive class loader loads classes from the WAR, EAR, and JAR files or directories (for directory deployment) of applications
or modules deployed in Payara  Server.

This class loader also loads any application-specific classes generated by the Payara Server runtime, such as stub classes or servlets generated by JSP pages.
|===

[[delegation]]
== Delegation

Note that the class loader hierarchy is not a Java inheritance hierarchy, but a *delegation* hierarchy. In the delegation design, a class loader delegates class loading to its parent  before attempting to load a class itself. If the parent class loader cannot load a class, the class loader attempts to load the class itself.

In effect, a class loader is responsible for loading only the classes not available to the parent. Classes loaded by a class loader higher in the hierarchy cannot refer to classes available lower in the hierarchy.

The Jakarta Servlet specification recommends that a web module's class loader look in the local class loader before delegating to its parent.

You can make this class loader follow the delegation inversion model in the Servlet specification by setting `delegate="false"` in the `class-loader`
element of the `payara-web.xml` file. It is safe to do this only for a web module that does not interact with any other modules. For more details,
see "xref:docs:application-deployment-guide:dd-elements.adoc#class-loader[class-loader]" in the Payara Server Application Deployment Guide.

The default value is `delegate="true"`, which causes a web module's class loader to delegate in the same manner as the other class loaders.
You must use `delegate="true"` for a web application that accesses EJB components or that acts as a web service client or endpoint.

For a number of packages, including `java.\*` and `jakarta.\*`, symbol resolution is always delegated to the parent class loader regardless of the `delegate` setting. This prevents applications from overriding core Java runtime classes or changing the API versions of specifications that are part of the Jakarta EE platform.

[[using-the-java-optional-package-mechanism]]
== Using the Java Optional Package Mechanism

Optional packages are packages of Java classes and associated native code that application developers can use to extend the functionality of the core platform.

To use the Java optional package mechanism, copy the JAR files into the `${domain-dir}/lib/ext` directory and then restart the server, or use the `asadmin add-library` command with the `--type ext` option.

Libraries configured in this manner are loaded by the bootstrap classloader in sequence by making them part of the server instance's classpath.

For more information about the `asadmin add-library` command, see the Payara Server Reference Manual.

NOTE: The `${domain-dir}/lib/ext` directory was used in previous versions of Payara Server as part of its dedicated *Extension Classloader*, which used Java's own extension library support to allow libraries to be added to an existing domain as extensions. +
The extension library mechanism was officially removed from Java 11 onwards and thus its dedicated classloader was removed but the directory has remained for backwards compatibility purposes.

[[class-loader-universes]]
== Class Loader Universes

Access to components within applications and modules installed on the server occurs within the context of isolated class loader universes, each of which has its own _Applib_ and _Archive_ classloaders.

Application Universe:: Each application has its own class loader universe, which loads the classes in all the modules in the application.

Individually Deployed Module Universe:: Each individually deployed EJB JAR or web WAR has its own class loader universe, which loads the classes in the module.

A resource such as a file that is accessed by a servlet, JSP, or EJB component must be in one of the following locations:

* A directory pointed to by the Libraries field or `--libraries` option used during deployment
* A directory pointed to by the `library-directory` element in the `application.xml` deployment descriptor
* A directory pointed to by the application or module's classpath; for example, a web module's classpath includes these directories:
+
[source,text]
----
module-name/WEB-INF/classes
module-name/WEB-INF/lib
----

[[application-specific-class-loading]]
== Application-Specific Class Loading

You can specify module or application-specific library classes in one of the following ways:

* Use the Administration Console. Open the _Applications_ component, then go to the page for the type of application or module. Select the _Deploy_ button. Type the comma-separated paths in the _Libraries_ field.

* Use the `asadmin deploy` command with the `--libraries` option and specify comma-separated paths. For more details, see the xref:docs:reference-manual:deploy.adoc[Payara Server Reference Manual].

* Use the `asadmin add-library` command with the `--type app` option. For details, see the xref:docs:reference-manual:add-library.adoc[add-library].

NOTE: None of these alternatives apply to application clients. For more information, see xref:docs:application-development-guide:java-clients.adoc#using-libraries-with-application-clients[Using Libraries with Application Clients].

You can update a library JAR file using dynamic reloading or by restarting (disabling and re-enabling) a module or application. To add or remove library JAR files, you can redeploy the module or application. Application libraries are included in the _Applib_ class loader. Paths to libraries can be relative or absolute.

A relative path is relative to `${domain-dir}/lib/applibs`. If the path is absolute, the path must be accessible to the domain administration server (DAS). Payara Server automatically synchronizes these libraries to all remote instances when a cluster or deployment group is restarted. However,
libraries specified by absolute paths are not guaranteed to be synchronized.

TIP: You can also use application-specific class loading to access different versions of a library from different applications.

If multiple applications or modules refer to the same libraries, classes in those libraries are automatically shared. This can reduce the memory footprint and allow sharing of static information. However, applications or modules using application-specific libraries are not portable.

NOTE: If you see an access control error message when you try to use a library, you may need to grant permission to the library in the
`server.policy` file. For more information, see xref:securing-apps.adoc#changing-permissions-for-an-application[Changing Permissions for an Application].

[[circumventing-class-loader-isolation]]
== Circumventing Class Loader Isolation

Since each application or individually deployed module class loader universe is isolated, an application or module cannot load classes from another application or module. This prevents two similarly named classes in different applications or modules from interfering with each other.

To circumvent this limitation for libraries, utility classes, or individually deployed modules accessed by more than one application, you can include the relevant path to the required classes in one of these ways:

[[using-the-common-class-loader]]
=== Using the Common Class Loader

To use the Common class loader, copy the JAR files into the `${domain-dir}/lib` or `${as-install}/lib` directory and restart the server, or use the `asadmin add-library` command with the `--type common` option. For more information about the `asadmin add-library` command,
see the Payara Server Reference Manual.

Using the Common class loader makes an application or module accessible to all applications or modules deployed on servers that share the same configuration. However, this accessibility does not extend to application clients. For more information, see xref:docs:application-development-guide:java-clients.adoc#using-libraries-with-application-clients[Using Libraries with Application Clients].

For example, using the Common class loader is the recommended way of adding JDBC drivers to a Payara Server domain. For configurations of supported and other drivers, see "xref:docs:administration-guide:jdbc.adoc#configuration-specifics-for-jdbc-drivers[Configuration Specifics for JDBC Drivers]" in the Payara Server Administration Guide.

[[packaging-the-client-jar-for-one-application-in-another-application]]
=== Packaging the Client JAR for One Application in Another Application

By packaging the client JAR for one application in a second application, you allow an EJB or web component in the second application
to call an EJB component in the first (dependent) application, without making either of them accessible to any other application or module.

As an alternative for a production environment, you can have the Common class loader load the client JAR of the dependent application as
described in xref:docs:application-development-guide:class-loaders.adoc#using-the-common-class-loader[Using the Common Class Loader].

[[to-package-the-client-jar-for-one-application-in-another-application]]
=== To Package the Client JAR for One Application in Another Application

. Deploy the dependent application.

. Add the dependent application's client JAR file to the calling application.

* For a calling EJB component, add the client JAR file at the same level as the EJB component. Then add a `Class-Path` entry to the `MANIFEST.MF` file of the calling EJB component.
* For a calling web component, add the client JAR file under the `WEB-INF/lib` directory.
+
If you need to package the client JAR with both the EJB and web components, set `delegate="true"` attribute in the `class-loader` element of the `payara-web.xml` file.
+
This changes the Web class loader so that it follows the standard class loader delegation model and delegates to its parent before attempting to load a class itself.
+
For most applications, packaging the client JAR file with the calling EJB component is sufficient. You do not need to package the client JAR file with both the EJB and web components unless the web component is directly calling the EJB component in the dependent application.

. Deploy the "client" application. The calling EJB or web component must specify in its `glassfish-ejb-jar.xml` or `payara-web.xml` file the JNDI name of the EJB component in the dependent application. Using an `ejb-link` mapping does not work when the EJB component being called resides in another application.
+
TIP: You do not need to restart the server instance.
